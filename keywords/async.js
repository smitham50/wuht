module.exports = () => {
    console.log("");
    console.log("---------------");
    console.log("  async  ");
    console.log("---------------\n");

    console.log("An async function is a function declared with the async keyword, and the await keyword is permitted within them. The async and await keywords enable asynchronous,");
    console.log("promise-based behavior to be written in a cleaner style, avoiding the need to explicitly configure promise chains.\n");
    console.log("Async functions may also be defined as expressions.\n");
    console.log("  function resolveAfter2Seconds() {");
    console.log("    return new Promise(resolve => {");
    console.log("      setTimeout(() => {");
    console.log("        resolve('resolved');");
    console.log("      }, 2000);");
    console.log("    });");
    console.log("  }\n");
    console.log("  async function asyncCall() {");
    console.log("    console.log('calling');");
    console.log("    const result = await resolveAfter2Seconds();");
    console.log("    console.log(result);");
    console.log("    // expected output: 'resolved'");
    console.log("  }\n");
    console.log("  asyncCall();\n");

    console.log("---------------");
    console.log("  Syntax  ");
    console.log("---------------\n");

    console.log("  async function name([param[, param[, ...param]]]) {");
    console.log("    statements");
    console.log("  }\n");
    console.log("name:");
    console.log("    The function’s name.\n");
    console.log("param:");
    console.log("    The name of an argument to be passed to the function.\n");
    console.log("statements:");
    console.log("    The statements comprising the body of the function.  The await mechanism may be used.\n");
    console.log("Return value:");
    console.log("    A Promise which will be resolved with the value returned by the async function, or rejected with an exception thrown from, or uncaught within, the async function.\n");

    console.log("---------------");
    console.log("  Description  ");
    console.log("---------------\n");

    console.log("Async functions can contain zero or more await expressions. Await expressions make promise-returning functions behave as though they're synchronous by suspending");
    console.log("execution until the returned promise is fulfilled or rejected. The resolved value of the promise is treated as the return value of the await expression. Use of async");
    console.log("and await enables the use of ordinary try / catch blocks around asynchronous code.\n");
    console.log("The await keyword is only valid inside async functions within regular JavaScript code. If you use it outside of an async function's body, you will get a SyntaxError.\n");
    console.log("await can be used on its own with JavaScript modules.\n");
    console.log("The purpose of async/await is to simplify the syntax necessary to consume promise-based APIs. The behavior of async/await is similar to combining generators and promises.\n");
    console.log("Async functions always return a promise. If the return value of an async function is not explicitly a promise, it will be implicitly wrapped in a promise.\n");
    console.log("For example, the following:\n");
    console.log("  async function foo() {");
    console.log("    return 1");
    console.log("  }\n");
    console.log("...is equivalent to:\n");
    console.log("  function foo() {");
    console.log("    return Promise.resolve(1)");
    console.log("  }\n");
    console.log("The body of an async function can be thought of as being split by zero or more await expressions. Top-level code, up to and including the first await expression (if there");
    console.log("is one), is run synchronously. In this way, an async function without an await expression will run synchronously. If there is an await expression inside the function body,");
    console.log("however, the async function will always complete asynchronously.\n");
    console.log("For example:\n");
    console.log("  async function foo() {");
    console.log("    await 1");
    console.log("  }\n");
    console.log("...is equivalent to:\n");
    console.log("  function foo() {");
    console.log("    return Promise.resolve(1).then(() => undefined)");
    console.log("  }\n");
    console.log("Code after each await expression can be thought of as existing in a .then callback. In this way a promise chain is progressively constructed with each reentrant step");
    console.log("through the function. The return value forms the final link in the chain.\n");
    console.log("In the following example, we successively await two promises. Progress moves through function foo in three stages.\n");
    console.log("    1. The first line of the body of function foo is executed synchronously, with the await expression configured with the pending promise. Progress through foo is then");
    console.log("       suspended and control is yielded back to the function that called foo.\n");
    console.log("    2. Some time later, when the first promise has either been fulfilled or rejected, control moves back into foo. The result of the first promise fulfillment (if it was");
    console.log("       not rejected) is returned from the await expression. Here 1 is assigned to result1. Progress continues, and the second await expression is evaluated. Again, progress");
    console.log("       through foo is suspended and control is yielded.\n");
    console.log("    3. Some time later, when the second promise has either been fulfilled or rejected, control re-enters foo. The result of the second promise resolution is returned from");
    console.log("       the second await expression. Here 2 is assigned to result2. Control moves to the return expression (if any). The default return value of undefined is returned as");
    console.log("       the resolution value of the current promise.\n");
    console.log("  async function foo() {");
    console.log("    const result1 = await new Promise((resolve) => setTimeout(() => resolve('1')))");
    console.log("    const result2 = await new Promise((resolve) => setTimeout(() => resolve('2')))");
    console.log("  }");
    console.log("  foo()\n");
    console.log("Note how the promise chain is not built-up in one go. Instead, the promise chain is constructed in stages as control is successively yielded from and returned to the");
    console.log("async function. As a result, we must be mindful of error handling behavior when dealing with concurrent asynchronous operations.\n");
    console.log("For example, in the following code an unhandled promise rejection error will be thrown, even if a .catch handler has been configured further along the promise chain. This");
    console.log("is because p2 will not be 'wired into' the promise chain until control returns from p1.\n");
    console.log("  async function foo() {");
    console.log("    const p1 = new Promise((resolve) => setTimeout(() => resolve('1'), 1000))");
    console.log("    const p2 = new Promise((_, reject) => setTimeout(() => reject('2'), 500))");
    console.log("    const results = [await p1, await p2] // Do not do this! Use Promise.all or Promise.allSettled instead.");
    console.log("  }");
    console.log("  foo().catch(() => { }) // Attempt to swallow all errors...\n");

    console.log("---------------");
    console.log("  Examples  ");
    console.log("---------------\n");

    console.log("- Async functions and execution order -\n");

    console.log("  function resolveAfter2Seconds() {");
    console.log("    console.log('starting slow promise')");
    console.log("    return new Promise(resolve => {");
    console.log("      setTimeout(function () {");
    console.log("        resolve('slow')");
    console.log("        console.log('slow promise is done')");
    console.log("      }, 2000)");
    console.log("    })");
    console.log("  }\n");
    console.log("  function resolveAfter1Second() {");
    console.log("    console.log('starting fast promise')");
    console.log("    return new Promise(resolve => {");
    console.log("      setTimeout(function () {");
    console.log("        resolve('fast')");
    console.log("        console.log('fast promise is done')");
    console.log("      }, 1000)");
    console.log("    })");
    console.log("  }\n");
    console.log("  async function sequentialStart() {");
    console.log("    console.log('==SEQUENTIAL START==')\n");
    console.log("    // 1. Execution gets here almost instantly");
    console.log("    const slow = await resolveAfter2Seconds()");
    console.log("    console.log(slow) // 2. this runs 2 seconds after 1.\n");
    console.log("    const fast = await resolveAfter1Second()");
    console.log("    console.log(fast) // 3. this runs 3 seconds after 1.");
    console.log("  }\n");
    console.log("  async function concurrentStart() {");
    console.log("    console.log('==CONCURRENT START with await==');");
    console.log("    const slow = resolveAfter2Seconds() // starts timer immediately");
    console.log("    const fast = resolveAfter1Second() // starts timer immediately\n");
    console.log("    // 1. Execution gets here almost instantly");
    console.log("    console.log(await slow) // 2. this runs 2 seconds after 1.");
    console.log("    console.log(await fast) // 3. this runs 2 seconds after 1., immediately after 2., since fast is already resolved");
    console.log("  }\n");
    console.log("  function concurrentPromise() {");
    console.log("    console.log('==CONCURRENT START with Promise.all==')");
    console.log("    return Promise.all([resolveAfter2Seconds(), resolveAfter1Second()]).then((messages) => {");
    console.log("      console.log(messages[0]) // slow");
    console.log("      console.log(messages[1]) // fast");
    console.log("    })");
    console.log("  }\n");
    console.log("  async function parallel() {");
    console.log("    console.log('==PARALLEL with await Promise.all==')\n");
    console.log("    // Start 2 'jobs' in parallel and wait for both of them to complete");
    console.log("    await Promise.all([");
    console.log("      (async () => console.log(await resolveAfter2Seconds()))(),");
    console.log("      (async () => console.log(await resolveAfter1Second()))()");
    console.log("    ])");
    console.log("  }\n");
    console.log("  sequentialStart() // after 2 seconds, logs 'slow', then after 1 more second, 'fast'\n");
    console.log("  // wait above to finish");
    console.log("  setTimeout(concurrentStart, 4000) // after 2 seconds, logs 'slow' and then 'fast'\n");
    console.log("  // wait again");
    console.log("  setTimeout(concurrentPromise, 7000) // same as concurrentStart\n");
    console.log("  // wait again");
    console.log("  setTimeout(parallel, 10000) // truly parallel: after 1 second, logs 'fast', then after 1 more second, 'slow'\n");

    console.log("- await and parallelism -\n");
    
    console.log("In sequentialStart, execution suspends 2 seconds for the first await, and then another second for the second await. The second timer is not created until the first has");
    console.log("already fired, so the code finishes after 3 seconds.\n");
    console.log("In concurrentStart, both timers are created and then awaited. The timers run concurrently, which means the code finishes in 2 rather than 3 seconds, i.e. the slowest");
    console.log("timer. However, the await calls still run in series, which means the second await will wait for the first one to finish.In this case, the result of the fastest timer is");
    console.log("processed after the slowest.\n");
    console.log("If you wish to safely perform two or more jobs in parallel, you must await a call to Promise.all, or Promise.allSettled.\n");
    console.log("Error handling:\n");
    console.log("Note that functions concurrentStart and concurrentPromise are not functionally equivalent.\n");
    console.log("In concurrentStart, if promise fast rejects before promise slow is fulfilled, then an unhandled promise rejection error will be raised, regardless of whether the caller");
    console.log("has configured a catch clause.\n");
    console.log("In concurrentPromise, Promise.all wires up the promise chain in one go, meaning that the operation will fail-fast regardless of the order of rejection of the promises,");
    console.log("and the error will always occur within the configured promise chain, enabling it to be caught in the normal way.\n");

    console.log("- Rewriting a Promise chain with an async function -\n");
    
    console.log("An API that returns a Promise will result in a promise chain, and it splits the function into many parts. Consider the following code:\n");
    console.log("  function getProcessedData(url) {");
    console.log("    return downloadData(url) // returns a promise");
    console.log("      .catch(e => {");
    console.log("        return downloadFallbackData(url)  // returns a promise");
    console.log("      })");
    console.log("      .then(v => {");
    console.log("        return processDataInWorker(v)  // returns a promise");
    console.log("      })");
    console.log("  }\n");
    console.log("it can be rewritten with a single async function as follows:\n");
    console.log("  async function getProcessedData(url) {");
    console.log("    let v");
    console.log("    try {");
    console.log("      v = await downloadData(url)");
    console.log("    } catch (e) {");
    console.log("      v = await downloadFallbackData(url)");
    console.log("    }");
    console.log("    return processDataInWorker(v)");
    console.log("  }\n");
    console.log("In the above example, notice there is no await statement after the return keyword, although that would be valid too: The return value of an async function is implicitly");
    console.log("wrapped in Promise.resolve - if it's not already a promise itself (as in this example).\n");
    
    console.log("- return await promiseValue vs. return promiseValue -\n");
    
    console.log("The implicit wrapping of return values in Promise.resolve does not imply that return await promiseValue is functionally equivalent to return promiseValue.\n");
    console.log("Consider the following rewrite of the above code. It returns null if processDataInWorker rejects with an error:\n");
    console.log("  async function getProcessedData(url) {");
    console.log("    let v");
    console.log("    try {");
    console.log("      v = await downloadData(url)");
    console.log("    } catch (e) {");
    console.log("      v = await downloadFallbackData(url)");
    console.log("    }");
    console.log("    try {");
    console.log("      return await processDataInWorker(v)  // Note the `return await` vs. just `return`");
    console.log("    } catch (e) {");
    console.log("      return null");
    console.log("    }");
    console.log("  }\n");
    console.log("Writing return processDataInWorker(v) would have caused the Promise returned by the function to reject, instead of resolving to null if processDataInWorker(v) rejects.\n");
    console.log("This highlights the subtle difference between return foo; and return await foo; — return foo immediately returns foo and never throws, even if foo is a Promise that");
    console.log("rejects. return await foo will wait for foo to resolve or reject if it's a Promise, and throws before returning if it rejects.\n");
}